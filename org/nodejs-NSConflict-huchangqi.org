* 前端知识
- HTML 
    - 什么是doctype
    - 行内元素和块级元素
    - 流行的浏览器内核
    - html 语义化

- CSS
    - 选择器
    - 盒模型
    - 浮动与清除浮动
    - 定位
    - 兼容性处理
    - 响应式设计
    - 布局技巧
    - 性能优化 
    - css 预处理器
    
- JS 基础
    - 变量与函数声明
    - 作用域
    - this对象
    - 闭包
    - 数组方法
    - 对象和JSON
    - 原型与原型链
    - 继承与多态
    - call 与 apply
    - ajax
    - 异步与同步的区别
    - 跨域处理
    - window 对象
    - 正则表达式
    - 事件处理
    - DOM 操作

- JS 进阶
    - Promise 对象
    - 各类模块加载器及其原理
        - requirejs
            - 加载机制
        - seajs
            - 加载机制
            - seajs的懒加载
    - 移动端开发
        - 事件处理
        - 解决点透问题
    - 前端构建工具的使用
        - webpack的使用
        - fis的使用
    - ES6
        - generator
        - let, var, const
        - 函数的扩展
        - 数组的扩展
        - 对象的扩展
        - class
    - 异步处理
        - Promise
        - async await
    - jquery 相关源码剖析
        - 链式调用
        - 事件
        - ajax
        - 选择器
        - 缓存

- Node.js
    - 什么是Node.js
    - node.js的模块机制
    - node.js的核心模块
    - 理解异步I/O
    - express 基本使用
    - gulp 自动化工具流
    - 数据库连接与操作
    - 路由操作
    - 登陆验证
    - 中间件
    - orm 数据库对象模型
    - 安全验证
    - 搭建一个简单博客系统

-  JS 高级
    - React 框架使用
        - JSX
        - 组件
        - 子节点和数据传递
        - 神奇的ref属性
        - 事件
        - 组件的声明周期
        - 控制渲染来优化性能
        - 通过后端渲染来提升首屏
    - Redux的使用
        - Redux 的开发守则
        - Actions
        - Reducers
        - Store
        - react-redux
        - 使用redux-devtools
        - 异步Actions
        - 异步数据流
        - 中间件
        - 基于redux react的后端渲染
    - 完整开发一个spa应用
* 重新认识js
 [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript]]
* 代码组织和部署
** 模块路径解释规则
   1. 内置模块
   2. node_modules 目录
   3. NODE_PATH 环境变量
** package
   1. index.js 模块的文件名是index.js
   2. package.json 包目录下包含一个 package.json
* 对象 
  js 中所有的数据类型都是对象(object)
  js 中，对象就是一个键/值 对的集合 你可以把js的对象想象成一个键为字符串类型的字典 值可以是字符串，数字，函数

  1. 使用构造函数模拟"类”， 在内部使用this 指代实例对象
  2. Object.create()
  3. createNew
     #+BEGIN_SRC js
       var Cat = {
           createNew: function(){
               var cat = {};
               cat.name = "maomao";
               cat.makeSound = function(){alert("wangwang");};
               return cat;
           }
       }
       //使用的时候调用createNew()

       var cat1 = Cat.createNew();
       cat1.makeSound();
     #+END_SRC
** 继承
   prototype属性 (prototype对象）
   所用实例对象需要共享的属性和方法，都放在这个对象中，不需要共享的属性和方法就放在构造函数里面
   实例对象一旦创建，自动引用prototype对象的属性和方法，实例对象的属性和方法分成两种，一种在本地，一种是引用
* function
  [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions]]
  1. 函数声明 
     function name(param){
     
     }
  2. 函数表达式
     var name = function(param){
   
  }
  3. 函数构造器 (低效)
     var adder = new Function("a","b","return a + b");
* 闭包
  闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。
  换句话说，这些函数可以“记忆”它被创建时候的环境。
  [[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures]]
* 原型
* exports 和 module.exports 区别
  1. module.exports 初始化一个空对象{}
  2. exports 是指向 module.exports 的引用
  3. require() 返回的是 module.exports 而不是 exports
* promise
  promise 对象就是对一个异步任务的封装
  promise 提供了then方法 (catch finally 都是特殊的then
  then 方法 接受一个function 或者 是一个 promise 对象
** then
   传入function
   then 对function 的返回值判断是不是 promise 对象
   1. 是 把它插入到当前链式操作中，后面的then 会在这个promise 对象完成之后继续
   2. 否 把这个返回值传入到下一个then中
   
   传入promise对象
   等待该promise对象执行完成，再执行当前的链，
* 异步，回调，EventLoop
  1. 不是回调
     #+BEGIN_SRC js : results output
       function Foo(a, cb) {
           console.log(a);
           //do something
           cb(Math.random());
       }
       var callback = function(num){
           console.log(num);
       }
       Foo(2, callback);
     #+END_SRC
  2. 异步
     #+BEGIN_SRC js
       function Add(a, b){
           return a+b;
       }
       function LazyAdd(a){
           return function(b){
               return a+b;
           }
       }

       // result 是一个闭包 ，我们把一个持有外层参数a的匿名函数构成的闭包保存到变量result中
       // 极端情况 var result = LazyAdd(1)(2); 不属于异步， 和同步没区别
       var result = LazyAdd(1);

       // do something
       // 实际生产中可能等待一些条件成立，再去执行另一半

       result = result(2)
     #+END_SRC
  3. 回调
     #+BEGIN_SRC js
       function Add(a, b) {
           return a+b;
       }
       // LazyAdd 多了一个参数cb
       function LazyAdd(a, cb){
           return function(b){
               cb(a, b);
           }
       }
       // 将Add传给形参cb
       var result = LazyAdd(1, Add)
       //do something
       result = result(2);
     #+END_SRC
     // 带有状态的才叫回调函数，own state，这里通过闭包保存的a就是状态
* c++ 
  [[https://nodejs.org/dist/latest-v6.x/docs/api/addons.html]]
